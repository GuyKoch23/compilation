/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import AST.*;

parser code 
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");		
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getCharPos());
		System.out.print("] ");		
		System.exit(0);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getCharPos());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s; 
:};

terminal
    // Keywords
    CLASS, EXTENDS, NEW, RETURN, IF, WHILE, ARRAY,
    TYPE_INT, TYPE_STRING, TYPE_VOID,

    // Symbols
    ASSIGN, EQ, PLUS, MINUS, TIMES, DIVIDE, LT, GT, LPAREN, RPAREN,
    LBRACE, RBRACE, LBRACK, RBRACK, DOT, COMMA, SEMICOLON,

    // Literals
    ID, INT, STRING, NIL;

non terminal
    program, dec, type, varDec, funcDec, classDec, arrayTypedef,
    exp, var, stmt, newExp, cField;

precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

start with program;
 
program ::= decList:v {: 
    RESULT = new AST_PROGRAM(v);
:};

decList ::= dec:d {: RESULT = new AST_DEC_LIST(d, null); :}
          | dec:d decList:l {: RESULT = new AST_DEC_LIST(d, l); :}

dec ::= varDec {: RESULT = new AST_VAR_DEC($1); :}
    | funcDec {: RESULT = new AST_FUNC_DEC($1); :}
    | classDec {: RESULT = new AST_CLASS_DEC($1); :}
    | arrayTypedef {: RESULT = new AST_ARRAY_TYPEDEF_DEC($1); :};

type ::= TYPE_INT {: RESULT = new AST_TYPE_INT(); :}
      | TYPE_STRING {: RESULT = new AST_TYPE_STRING(); :}
      | TYPE_VOID {: RESULT = new AST_TYPE_VOID(); :}
      | ID {: RESULT = new AST_TYPE_ID($1); :};

varDec ::= type ID SEMICOLON {: 
    RESULT = new AST_VAR_DER($1, $2, null);
:}
       | type ID ASSIGN exp SEMICOLON {: 
    RESULT = new AST_VAR_DER($1, $2, $4); 
:};
       | type ID ASSIGN newExp SEMICOLON {: 
    RESULT = new AST_VAR_DER($1, $2, $4); 
:};

funcDec ::= type ID LPAREN paramListOpt RPAREN LBRACE stmtList RBRACE {: 
    RESULT = new AST_FUNC_DEC($1, $2, $4, $7); 
:};

paramListOpt ::= /* empty */ {: RESULT = new AST_PARAM_LIST(); :}
                | paramList {: RESULT = new AST_PARAM_LIST($1); :};

paramList ::= type ID {: RESULT = new AST_PARAM_LIST(new AST_PARAM($1, $2), null); :}
            | type ID COMMA paramList {: RESULT = new AST_PARAM_LIST(new AST_PARAM($1, $2), $4); :};

classDec ::= CLASS ID LBRACE cFieldList RBRACE {: 
    RESULT = new AST_CLASS_DEC($2, null, $4); 
:}
          | CLASS ID EXTENDS ID LBRACE cFieldList RBRACE {: 
    RESULT = new AST_CLASS_DEC($2, $4, $6); 
:};

cFieldList ::= cField:c {: RESULT = new AST_CFIELD_LIST(c, null); :}
          | cField:c cFieldList:l {: RESULT = new AST_CFIELD_LIST(c, l); :}

arrayTypedef ::= ARRAY ID EQ type LBRACK RBRACK SEMICOLON {: 
    RESULT = new AST_ARRAY_TYPEDEF($2, $4); 
:};

exp ::= var {: RESULT = new AST_EXP_VAR($1); :}
     | LPAREN exp RPAREN {: RESULT = new AST_EXP_VAR($2); :}
     | exp BINOP exp {: 
    RESULT = new AST_EXP_BINOP($1, $3, $2); 
:}
     | ID LPAREN expList RPAREN {: 
    RESULT = new AST_EXP_FUNC_CALL($1, $3); 
:}
     | MINUS INT {: 
    RESULT = new AST_EXP_UNARY($1); 
:}
     | STRING {: 
    RESULT = new AST_EXP_STRING($1); 
:}
     | INT {: 
    RESULT = new AST_EXP_INT($1); 
:};

var ::= ID {: RESULT = new AST_VAR_SIMPLE($1); :}
     | var DOT ID {: 
    RESULT = new AST_VAR_FIELD($1, $3); 
:}
     | var LBRACK exp RBRACK {: 
    RESULT = new AST_VAR_SUBSCRIPT($1, $3); 
:};

stmt ::= varDec
      | var ASSIGN exp SEMICOLON {: 
    RESULT = new AST_STMT_ASSIGN($1, $3); 
:}
      | RETURN exp? SEMICOLON {: 
    RESULT = new AST_STMT_RETURN($2); 
:}
      | IF LPAREN exp RPAREN LBRACE stmtList RBRACE {: 
    RESULT = new AST_STMT_IF($3, $6); 
:}
      | WHILE LPAREN exp RPAREN LBRACE stmtList RBRACE {: 
    RESULT = new AST_STMT_WHILE($3, $6); 
:}
      | ID LPAREN expList RPAREN SEMICOLON {: 
    RESULT = new AST_STMT_FUNC_CALL($1, $3); 
:};

newExp ::= NEW type {: 
    RESULT = new AST_NEW_EXP($2); 
:}
        | NEW type LBRACK exp RBRACK {: 
    RESULT = new AST_NEW_ARRAY($2, $4); 
:};

cField ::= varDec
         | funcDec;

