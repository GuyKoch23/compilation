/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import AST.*;

parser code 
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");		
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getCharPos());
		System.out.print("] ");		
		System.exit(0);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getCharPos());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s; 
:};

terminal
    // Keywords
    CLASS, EXTENDS, NEW, RETURN, IF, WHILE, ARRAY,
    TYPE_INT, TYPE_STRING, TYPE_VOID,

    // Symbols
    ASSIGN, EQ, PLUS, MINUS, TIMES, DIVIDE, LT, GT, LPAREN, RPAREN,
    LBRACE, RBRACE, LBRACK, RBRACK, DOT, COMMA, SEMICOLON,

    // Literals
    ID, INT, STRING, NIL;

non terminal
    program, dec, type, varDec, funcDec, classDec, arrayTypedef,
    exp, var, stmt, newExp, cField;

precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

start with program;

decList ::= dec:d {: RESULT = new AST_DEC_WRAPPER_LIST(d, null); :}
          | dec:d decList:l {: RESULT = new AST_DEC_WRAPPER_LIST(d, l); :}

program ::= decList:dLst {: 
    RESULT = new AST_PROGRAM(dLst);
:};

dec ::= varDec:v {: RESULT = new AST_DEC_WRAPPER(v); :}
    | funcDec:f {: RESULT = new AST_DEC_WRAPPER(f); :}
    | classDec:c {: RESULT = new AST_DEC_WRAPPER(c); :}
    | arrayTypedef:a {: RESULT = new AST_DEC_WRAPPER(a); :};

type ::= TYPE_INT {: RESULT = new AST_TYPE_INT(); :}
      | TYPE_STRING {: RESULT = new AST_TYPE_STRING(); :}
      | TYPE_VOID {: RESULT = new AST_TYPE_VOID(); :}
      | ID {: RESULT = new AST_TYPE_ID($1); :};

varDec ::= type:t ID:i SEMICOLON {: 
    RESULT = new AST_VAR_DEC(t, i, null);
:}
       | type:t ID:i ASSIGN exp:e SEMICOLON {: 
    RESULT = new AST_VAR_DEC(t, i, e); 
:};
       | type:t ID:i ASSIGN newExp:e SEMICOLON {: 
    RESULT = new AST_VAR_DEC(t, i, e); 
:};

funcDec ::= type:t ID:i LPAREN paramListOpt:pLst RPAREN LBRACE stmtList:stLst RBRACE {: 
    RESULT = new AST_FUNC_DEC(t, i, pLst, stLst); 
:};

paramListOpt ::= /* empty */ {: RESULT = new AST_PARAM_LIST(); :}
                | paramList:l {: RESULT = new AST_PARAM_LIST(l); :};

paramList ::= type:t ID:i {: RESULT = new AST_PARAM_LIST(new AST_PARAM(t, i), null); :}
            | type:t ID:i COMMA paramList:l {: RESULT = new AST_PARAM_LIST(new AST_PARAM(t, i), l); :};

stmtList ::= stmt:s {: RESULT = new AST_STMT_LIST(new AST_STMT_WRAPPER(s), null); :}
            | stmt:s {: RESULT = new AST_STMT_LIST(new AST_STMT_WRAPPER(s), l); :};

classDec ::= CLASS ID:i LBRACE cFieldList:l RBRACE {: 
    RESULT = new AST_CLASS_DEC(i, null, l); 
:}
          | CLASS ID:ci EXTENDS ID:ei LBRACE cFieldList:l RBRACE {: 
    RESULT = new AST_CLASS_DEC(ci, ei, l); 
:};

cFieldList ::= cField:c {: RESULT = new AST_CFIELD_LIST(c, null); :}
          | cField:c cFieldList:l {: RESULT = new AST_CFIELD_LIST(c, l); :}

arrayTypedef ::= ARRAY ID:i EQ type:t LBRACK RBRACK SEMICOLON {: 
    RESULT = new AST_ARRAY_TYPEDEF(i, t); 
:};

exp ::= var:v {: RESULT = new AST_EXP_VAR(v); :}
     | LPAREN exp:e RPAREN {: RESULT = new AST_EXP_EXP(e); :}
     | exp:e1 BINOP:b exp:e2 {: 
    RESULT = new AST_EXP_BINOP(e1, e2, b); 
:}
     | ID LPAREN expList RPAREN {: 
    RESULT = new AST_EXP_FUNC_CALL($1, $3); 
:}
     | MINUS INT:i {: 
    RESULT = new AST_EXP_MINUS_INT(i); 
:}
     | INT:i {: 
    RESULT = new AST_EXP_INT(i); 
:};
     | STRING:s {: 
    RESULT = new AST_EXP_STRING(s); 
:}
     | NIL {: 
    RESULT = new AST_EXP_NIL(); 
:};
     | ID:i LPAREN RPAREN {: 
    RESULT = new AST_EXP_FUNC(null, i, null); 
:}; 
     | ID:i LPAREN expListOpt:eLst RPAREN {: 
    RESULT = new AST_EXP_FUNC(null, i, eLst); 
:}; 
     | var:v DOT ID:i LPAREN RPAREN {: 
    RESULT = new AST_EXP_FUNC(v, i, null); 
:}; 
     | var:v DOT ID:i LPAREN expListOpt:eLst RPAREN {: 
    RESULT = new AST_EXP_FUNC(v, i, eLst); 
:}; 

expListOpt ::= /* empty */ {: RESULT = new AST_EXP_WRAPPER_LIST(); :}
                | expList:l {: RESULT = new AST_EXP_WRAPPER_LIST(l); :};

expList ::= exp:e {: RESULT = new AST_EXP_WRAPPER_LIST(new AST_EXP_WRAPPER(e), null); :}
            | exp:e COMMA expList:l {: RESULT = new AST_EXP_WRAPPER_LIST(new AST_EXP_WRAPPER(e), l); :};

var ::= ID:i {: RESULT = new AST_VAR_SIMPLE(i); :}
     | var:v DOT ID:i {: 
    RESULT = new AST_VAR_FIELD(v, i); 
:}
     | var:v LBRACK exp:e RBRACK {: 
    RESULT = new AST_VAR_SUBSCRIPT(v, e); 
:};

stmt ::= varDec:v {: 
    RESULT = new AST_STMT_VAR_DEC(v); 
:}
      | var:v ASSIGN exp:e SEMICOLON {: 
    RESULT = new AST_STMT_ASSIGN(v, e); 
:}
      | var:v ASSIGN newExp:e SEMICOLON {: 
    RESULT = new AST_STMT_ASSIGN(v, e); 
:}
      | RETURN SEMICOLON {: 
    RESULT = new AST_STMT_RETURN(null); 
:}
      | RETURN exp:e SEMICOLON {: 
    RESULT = new AST_STMT_RETURN(e); 
:}
      | IF LPAREN exp:e RPAREN LBRACE stmtList:l RBRACE {: 
    RESULT = new AST_STMT_IF(e, l); 
:}
      | WHILE LPAREN exp:e RPAREN LBRACE stmtList:l RBRACE {: 
    RESULT = new AST_STMT_WHILE(e, l); 
:}
     | ID:i LPAREN RPAREN SEMICOLON {: 
    RESULT = new AST_STMT_FUNC(null, i, null); 
:}; 
     | ID:i LPAREN expListOpt:eLst RPAREN SEMICOLON {: 
    RESULT = new AST_STMT_FUNC(null, i, eLst); 
:}; 
     | var:v DOT ID:i LPAREN RPAREN SEMICOLON {: 
    RESULT = new AST_STMT_FUNC(v, i, null); 
:}; 
     | var:v DOT ID:i LPAREN expListOpt:eLst RPAREN SEMICOLON {: 
    RESULT = new AST_STMT_FUNC(v, i, eLst); 
:}; 

newExp ::= NEW type:t {: 
    RESULT = new AST_NEW_EXP(t, null); 
:}
        | NEW type:t LBRACK exp:e RBRACK {: 
    RESULT = new AST_NEW_EXP(t, e); 
:};

cfield ::= varDec:v {: RESULT = new AST_VAR_DEC(v); :}
    | funcDec:f {: RESULT = new AST_FUNC_DEC(f); :}

BINOP ::= PLUS {: RESULT = new AST_BINOP_PLUS(); :}
    | MINUS {: RESULT = new AST_BINOP_MINUS(); :}
    | TIMES {: RESULT = new AST_BINOP_TIMES(); :}
    | DIVIDE {: RESULT = new AST_BINOP_DIVIDE(); :}
    | LT {: RESULT = new AST_BINOP_LT(); :}
    | GT {: RESULT = new AST_BINOP_GT(); :}
    | EQ {: RESULT = new AST_BINOP_EQ(); :};