/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import AST.*;

parser code 
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");		
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getCharPos());
		System.out.print("] ");		
		System.exit(0);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getCharPos());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s; 
:};

terminal CLASS;
terminal EXTENDS;
terminal NEW;
terminal RETURN;
terminal IF;
terminal WHILE;
terminal ARRAY;
terminal EQ;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal LT;
terminal GT;
terminal LPAREN;
terminal RPAREN;
terminal LBRACE;
terminal RBRACE;
terminal LBRACK;
terminal RBRACK;
terminal DOT;
terminal COMMA;
terminal SEMICOLON;
terminal NIL;

terminal String TYPE_INT;
terminal String TYPE_STRING;
terminal String TYPE_VOID;
terminal String ID;

terminal Integer INT;
terminal String STRING;

non terminal AST_PROGRAM program; 
non terminal AST_DEC_WRAPPER dec;
non terminal AST_TYPE type;
non terminal AST_VAR_DEC varDec;
non terminal AST_FUNC_DEC funcDec;
non terminal AST_CLASS_DEC classDec;
non terminal AST_ARRAY_TYPEDEF arrayTypedef;
non terminal AST_EXP exp;
non terminal AST_EXP_VAR var;
non terminal AST_STMT stmt;
non terminal AST_NEW_EXP newExp;
non terminal AST_CFIELD cField;
non terminal AST_PARAM_LIST paramListOpt;
non terminal AST_PARAM_LIST paramList;
non terminal AST_STMT_LIST stmtList;
non terminal AST_CFIELD_LIST cFieldList;
non terminal AST_EXP_WRAPPER_LIST expListOpt;
non terminal AST_EXP_WRAPPER_LIST expList;
non terminal AST_BINOP BINOP;
non terminal AST_DEC_WRAPPER_LIST decList;

precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

start with program;
 
program ::= decList:dLst {: 
    RESULT = new AST_PROGRAM(dLst);
:};

decList ::= dec:d {: RESULT = new AST_DEC_WRAPPER_LIST(d, null); :}
          | dec:d decList:l {: RESULT = new AST_DEC_WRAPPER_LIST(d, l); :};

dec ::= varDec:v {: RESULT = new AST_DEC_WRAPPER(v); :}
    | funcDec:f {: RESULT = new AST_DEC_WRAPPER(f); :}
    | classDec:c {: RESULT = new AST_DEC_WRAPPER(c); :}
    | arrayTypedef:a {: RESULT = new AST_DEC_WRAPPER(a); :};

type ::= TYPE_INT {: RESULT = new AST_TYPE_INT(); :}
      | TYPE_STRING {: RESULT = new AST_TYPE_STRING(); :}
      | TYPE_VOID {: RESULT = new AST_TYPE_VOID(); :}
      | ID:i {: RESULT = new AST_TYPE_ID(i); :};

varDec ::= type:t ID:i SEMICOLON {: 
    RESULT = new AST_VAR_DEC(t, i, null);
:}
       | type:t ID:i ASSIGN exp:e SEMICOLON {: 
    RESULT = new AST_VAR_DEC(t, i, e); 
:}
       | type:t ID:i ASSIGN newExp:e SEMICOLON {: 
    RESULT = new AST_VAR_DEC(t, i, e); 
:};

funcDec ::= type:t ID:i LPAREN paramListOpt:pLst RPAREN LBRACE stmtList:stLst RBRACE {: 
    RESULT = new AST_FUNC_DEC(t, i, pLst, stLst); 
:};

paramListOpt ::= /* empty */ {: RESULT = new AST_PARAM_LIST(null); :}
                | paramList:l {: RESULT = new AST_PARAM_LIST(l); :};

paramList ::= type:t ID:i {: RESULT = new AST_PARAM_LIST(new AST_PARAM(t, i), null); :}
            | type:t ID:i COMMA paramList:l {: RESULT = new AST_PARAM_LIST(new AST_PARAM(t, i), l); :};

stmtList ::= stmt:s {: RESULT = new AST_STMT_LIST(new AST_STMT_WRAPPER(s), null); :}
            | stmt:s stmtList:l {: RESULT = new AST_STMT_LIST(new AST_STMT_WRAPPER(s), l); :};

classDec ::= CLASS ID:i LBRACE cFieldList:l RBRACE {: 
    RESULT = new AST_CLASS_DEC(i, null, l); 
:}
          | CLASS ID:ci EXTENDS ID:ei LBRACE cFieldList:l RBRACE {: 
    RESULT = new AST_CLASS_DEC(ci, ei, l); 
:};

cFieldList ::= cField:c {: RESULT = new AST_CFIELD_LIST(c, null); :}
          | cField:c cFieldList:l {: RESULT = new AST_CFIELD_LIST(c, l); :};

arrayTypedef ::= ARRAY ID:i EQ type:t LBRACK RBRACK SEMICOLON {: 
    RESULT = new AST_ARRAY_TYPEDEF(i, t); 
:};

exp ::= var:v {: RESULT = new AST_EXP_VAR(v); :}
     | LPAREN exp:e RPAREN {: RESULT = new AST_EXP_WRAPPER(e); :}
     | exp:e1 BINOP:b exp:e2 {: 
    RESULT = new AST_EXP_BINOP(e1, e2, b); 
:}
     | MINUS INT:i {: 
    RESULT = new AST_EXP_MINUS_INT(i); 
:}
     | INT:i {: 
    RESULT = new AST_EXP_INT(i); 
:}
     | STRING:s {: 
    RESULT = new AST_EXP_STRING(s); 
:}
     | NIL {: 
    RESULT = new AST_EXP_NIL(); 
:}
     | ID:i LPAREN expListOpt:eLst RPAREN {: 
    RESULT = new AST_EXP_FUNC(null, i, eLst); 
:}
     | var:v DOT ID:i LPAREN expListOpt:eLst RPAREN {: 
    RESULT = new AST_EXP_FUNC(v, i, eLst); 
:}; 

expListOpt ::= /* empty */ {: RESULT = new AST_EXP_WRAPPER_LIST(null); :}
                | expList:l {: RESULT = new AST_EXP_WRAPPER_LIST(l); :};

expList ::= exp:e {: RESULT = new AST_EXP_WRAPPER_LIST(new AST_EXP_WRAPPER(e), null); :}
            | exp:e COMMA expList:l {: RESULT = new AST_EXP_WRAPPER_LIST(new AST_EXP_WRAPPER(e), l); :};

var ::= ID:i {: RESULT = new AST_VAR_SIMPLE(i); :}
     | var:v DOT ID:i {: 
    RESULT = new AST_VAR_FIELD(v, i); 
:}
     | var:v LBRACK exp:e RBRACK {: 
    RESULT = new AST_VAR_SUBSCRIPT(v, e); 
:};

stmt ::= varDec:v {: 
    RESULT = new AST_STMT_VAR_DEC(v); 
:}
      | var:v ASSIGN exp:e SEMICOLON {: 
    RESULT = new AST_STMT_ASSIGN(v, e); 
:}
      | var:v ASSIGN newExp:e SEMICOLON {: 
    RESULT = new AST_STMT_ASSIGN(v, e); 
:}
      | RETURN SEMICOLON {: 
    RESULT = new AST_STMT_RETURN(null); 
:}
      | RETURN exp:e SEMICOLON {: 
    RESULT = new AST_STMT_RETURN(e); 
:}
      | IF LPAREN exp:e RPAREN LBRACE stmtList:l RBRACE {: 
    RESULT = new AST_STMT_IF(e, l); 
:}
      | WHILE LPAREN exp:e RPAREN LBRACE stmtList:l RBRACE {: 
    RESULT = new AST_STMT_WHILE(e, l); 
:}
     | ID:i LPAREN expListOpt:eLst RPAREN SEMICOLON {: 
    RESULT = new AST_STMT_FUNC(null, i, eLst); 
:}
     | var:v DOT ID:i LPAREN expListOpt:eLst RPAREN SEMICOLON {: 
    RESULT = new AST_STMT_FUNC(v, i, eLst); 
:}; 

newExp ::= NEW type:t {: 
    RESULT = new AST_NEW_EXP(t, null); 
:}
        | NEW type:t LBRACK exp:e RBRACK {: 
    RESULT = new AST_NEW_EXP(t, e); 
:};

cField ::= varDec:v {: RESULT = new AST_VAR_DEC(v); :}
    | funcDec:f {: RESULT = new AST_FUNC_DEC(f); :};

BINOP ::= PLUS {: RESULT = new AST_BINOP_PLUS(); :}
    | MINUS {: RESULT = new AST_BINOP_MINUS(); :}
    | TIMES {: RESULT = new AST_BINOP_TIMES(); :}
    | DIVIDE {: RESULT = new AST_BINOP_DIVIDE(); :}
    | LT {: RESULT = new AST_BINOP_LT(); :}
    | GT {: RESULT = new AST_BINOP_GT(); :}
    | EQ {: RESULT = new AST_BINOP_EQ(); :};